"""
Email delivery functionality for ArXiv summarization pipeline.
Handles file attachments with size limits and error detection.
"""

import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email.mime.application import MIMEApplication
from email import encoders
from pathlib import Path
from dataclasses import dataclass
from typing import List, Tuple, Optional, Dict, Any
import logging

logger = logging.getLogger(__name__)

@dataclass
class DeliveryResult:
    success: bool
    files_sent: List[str]
    files_skipped: List[Tuple[str,str]] # (file_path, reason)
    files_too_large: List[str]
    error_files: List[str]
    email_size_mb: float

@dataclass
class DelivererConfig:
    smtp_server: str
    sender: str
    recipient: str
    password: str
    port: int=465
    max_attachment_size_mb: float=25.0


def _check_file_status(file_path: str, max_size_bytes: int) -> Tuple[str,Dict[str,Any]]:
    path = Path(file_path)
    filename = path.name.lower()

    if not path.exists():
        return 'missing', {'reason': 'File does not exist'}
    
    file_size = path.stat().st_size
    if file_size == 0:
        return 'empty', {'reason': 'File is empty', 'size_bytes': 0}
    
    if filename in ['error.txt', 'error.log']:
        return 'error', {'reason': 'Error file detected', 'size_bytes': file_size}
    
    if file_size > max_size_bytes:
        return 'too_large', {
            'reason': f'File size ({file_size/(1024*1024):.1f}MB) exceeds limit',
            'size_bytes': file_size
        }
    
    if 'summ_log' in filename:
        return 'log_file', {'size_bytes': file_size}
    
    return 'good', {'size_bytes': file_size}

def _create_email_content(files_sent: List[str], files_skipped: List[str],
                          files_too_large: List[str], error_files: List[str], log_files: List[str], summarizer_model: Optional[str]=None) -> str:
    lines = ["ArXiv Summarization Delivery Report", "="*40, ""]

    if files_sent:
        lines.extend([
            f"Successfully attached {len(files_sent)} file(s):",
            *[f"  • {Path(f).name}" for f in files_sent],
            ""
        ])
    
    if error_files:
        lines.extend([
            "Error files detected:",
            *[f"  • {Path(f).name}" for f in error_files],
            ""
        ])
    
    if files_too_large:
        lines.extend([
            "Files too large to attach:",
            *[f"  • {Path(f).name}" for f in files_too_large],
            ""
        ])
    
    if files_skipped:
        lines.extend([
            "Files skipped (missing/empty):",
            *[f"  • {Path(f).name}" for f in files_skipped],
            ""
        ])

    if log_files:
        lines.extend([
            "Log files:",
            *[f"  • {Path(f).name}" for f in log_files],
            ""
        ])
    
    # Add summary
    total_files = len(files_sent) + len(files_skipped) + len(files_too_large) + len(error_files) + len(log_files)
    lines.extend([
        f"Summary: {len(files_sent)}/{total_files} files successfully delivered",
        "",
        f"Generated by ArXiv AutoSumm, {summarizer_model}" if summarizer_model else "Generated by ArXiv AutoSumm"
    ])
    
    return "\n".join(lines)

def deliver(file_paths: List[str], config: DelivererConfig, subject: Optional[str]=None, summarizer_model: Optional[str]=None) -> DeliveryResult:
    files_sent = []
    files_skipped = []
    files_too_large = []
    error_files = []
    log_files = []

    max_size_bytes = int(config.max_attachment_size_mb*1024*1024)
    logger.info(f"Starting delivery to {config.recipient} with max size {config.max_attachment_size_mb}MB")

    attachments_data = []
    total_attachment_size = 0.0

    for file_path in file_paths:
        status, info = _check_file_status(file_path, max_size_bytes)

        if status == "good":
            files_sent.append(file_path)
            attachments_data.append((file_path, info["size_bytes"]))
            total_attachment_size += info["size_bytes"]
        elif status == "error":
            error_files.append(file_path)
            attachments_data.append((file_path, info["size_bytes"]))
            total_attachment_size += info["size_bytes"]
        elif status == "too_large":
            files_too_large.append(file_path)
            logger.warning(f"File too large: {Path(file_path).name}")
        elif status == "log_file":
            log_files.append(file_path)
            attachments_data.append((file_path, info["size_bytes"]))
            total_attachment_size += info["size_bytes"]
        else:
            files_skipped.append(file_path)
            logger.info(f"Skipping file: {Path(file_path).name}")

    msg = MIMEMultipart()
    msg['From'] = config.sender
    msg['To'] = config.recipient

    if subject:
        email_subject = subject
    else:
        if error_files or files_too_large or files_skipped:
            email_subject = "Arxiv Summary Delivery - Issues Detected"
        else:
            email_subject = "Arxiv Summary Delivery"
    
    msg['Subject'] = email_subject

    for file_path, file_size in attachments_data:
        try:
            with open(file_path, 'rb') as f:
                attachment = MIMEApplication(f.read())
                attachment.add_header(
                    'Content-Disposition',
                    'attachment',
                    filename=Path(file_path).name
                )
                msg.attach(attachment)
                logger.debug(f"Attached file: {Path(file_path).name}")
        except Exception as e:
            # if can't read a file that was supposed to be good, move it to skipped and continue
            if file_path in files_sent:
                files_sent.remove(file_path)
                files_skipped.append(file_path)
            elif file_path in error_files:
                error_files.remove(file_path)
                files_skipped.append(file_path)
            elif file_path in log_files:
                log_files.remove(file_path)
                files_skipped.append(file_path)

    body = _create_email_content(files_sent, files_skipped, files_too_large, error_files, log_files, summarizer_model)
    msg.attach(MIMEText(body,'plain'))

    email_size_bytes = len(msg.as_string())
    email_size_mb = email_size_bytes / (1024*1024)

    # Send email
    try:
        with smtplib.SMTP_SSL(config.smtp_server, config.port) as server:
            server.login(config.sender, config.password)
            server.sendmail(config.sender, config.recipient, msg.as_string())
            
        logger.info(f"Email sent to {config.recipient} successfully ({email_size_mb:.2f}MB)")
        print(f"Email sent to {config.recipient} successfully")
        print(f"Total email size: {email_size_mb:.2f}MB")
        print(f"Files attached: {len(files_sent + error_files)}")
        
        return DeliveryResult(
            success=True,
            files_sent=files_sent,
            files_skipped=files_skipped,
            files_too_large=files_too_large,
            error_files=error_files,
            email_size_mb=email_size_mb
        )
        
    except Exception as e:
        error_msg = f"Failed to send email: {str(e)}"
        logger.error(error_msg,exc_info=True)
        print(f"Error: {error_msg}")
        
        return DeliveryResult(
            success=False,
            files_sent=[],
            files_skipped=files_skipped,
            files_too_large=files_too_large,
            error_files=error_files,
            error=error_msg,
            email_size_mb=email_size_mb
        )


if __name__ == "__main__":
    pass